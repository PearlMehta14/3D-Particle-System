<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nebula Kinetic | Interactive Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            color: #fff;
            font-family: 'Outfit', 'Segoe UI', sans-serif;
        }

        #ui {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 10;
            background: rgba(10, 10, 15, 0.75);
            padding: 24px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            width: 240px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .stat {
            font-size: 0.75em;
            color: #00ffcc;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
            display: flex;
            align-items: center;
        }

        .stat::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #00ffcc;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.5);
                opacity: 0.5;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        label {
            font-size: 0.8em;
            color: #888;
            margin-top: 15px;
            display: block;
        }

        select {
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewbox='0 0 24 24' fill='none' stroke='white' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            cursor: pointer;
        }

        select option {
            background: #0a0a0f;
            color: #fff;
            padding: 12px;
        }

        select,
        input {
            width: 100%;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 12px;
            margin: 8px 0;
            border-radius: 10px;
            outline: none;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        select:hover,
        input:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: #00ffcc;
        }

        select:focus,
        input:focus {
            border-color: #00ffcc;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }

        #webcam {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 220px;
            border-radius: 12px;
            border: 2px solid rgba(0, 255, 204, 0.5);
            transform: scaleX(-1);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .controls-hint {
            font-size: 0.7em;
            line-height: 1.8;
            color: #aaa;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls-hint b {
            color: #00ffcc;
            margin-right: 5px;
        }

        #no-cam-tag {
            font-size: 0.6em;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: auto;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;700&display=swap" rel="stylesheet">
</head>

<body>

    <div id="ui">
        <div class="stat" id="status">
            <span id="status-text">Initializing AI...</span>
        </div>

        <label>System Geometry</label>
        <select id="template">
            <option value="saturn">Saturnian Rings</option>
            <option value="nebula">Orion Nebula</option>
            <option value="heart">Core Pulse</option>
            <option value="dna">Double Helix</option>
            <option value="vortex">Event Horizon</option>
        </select>

        <label>Plasma Tint</label>
        <input type="color" id="pColor" value="#00ccff">

        <div class="controls-hint">
            <b>üñêÔ∏è OPEN PALM:</b> Expand System<br>
            <b>‚úä FIST:</b> Gravity Well (Hold)<br>
            <b>‚úåÔ∏è TWO FINGERS:</b> "I MISS YOU" Mode<br>
            <b>üìç PALM MOVE:</b> Particles follow hand<br>
            <span id="ai-hint" style="display:block; margin-top: 10px; color: #00ffcc;"><b>NEURAL LINK:</b>
                Active</span>
        </div>
    </div>

    <video id="webcam" autoplay playsinline></video>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        // --- Configuration & State ---
        let particleCount = 20000;
        let isFist = false;
        let isTwoFingers = false;
        let targetExpansion = 1.0;
        let currentExpansion = 1.0;
        let mouseX = 0, mouseY = 0;
        let useAI = false;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        camera.position.z = 10;

        // --- Particle System Setup ---
        const geometry = new THREE.BufferGeometry();
        const posArray = new Float32Array(particleCount * 3);
        const targetArray = new Float32Array(particleCount * 3);
        const velocityArray = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i++) {
            posArray[i] = (Math.random() - 0.5) * 30;
            velocityArray[i] = 0;
        }

        const material = new THREE.PointsMaterial({
            size: 0.035,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            opacity: 0.8
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- Geometry Generators ---
        function createTextPoints(text, scale = 0.05) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 500; canvas.height = 100;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 70px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 250, 65);
            const imageData = ctx.getImageData(0, 0, 500, 100).data;
            const points = [];
            for (let y = 0; y < 100; y += 2) {
                for (let x = 0; x < 500; x += 2) {
                    if (imageData[(y * 500 + x) * 4 + 3] > 128) {
                        points.push({ x: (x - 250) * scale, y: (50 - y) * scale, z: (Math.random() - 0.5) * 0.2 });
                    }
                }
            }
            return points;
        }
        const textPointsArr = createTextPoints("I MISS YOU", 0.06);
        const helloPointsArr = createTextPoints("HELLO", 0.09); // Made larger as requested

        function setTemplate(type) {
            const currentType = type || document.getElementById('template').value;
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;
                if (currentType === 'text') {
                    const pt = textPointsArr[i % textPointsArr.length];
                    x = pt.x; y = pt.y; z = pt.z;
                } else if (currentType === 'hello') {
                    const pt = helloPointsArr[i % helloPointsArr.length];
                    x = pt.x; y = pt.y; z = pt.z;
                } else if (currentType === 'heart') {
                    const a = Math.random() * Math.PI * 2;
                    // Significantly scaled up heart (3.5x multiplier)
                    x = 2.5 * 1.6 * Math.pow(Math.sin(a), 3);
                    y = 2.5 * (1.3 * Math.cos(a) - 0.5 * Math.cos(2 * a) - 0.2 * Math.cos(3 * a) - 0.1 * Math.cos(4 * a));
                    // 3D Depth for the heart
                    z = (Math.random() - 0.5) * 2.0;
                } else if (currentType === 'dna') {
                    const h = (i / particleCount) * 12 - 6;
                    const angle = h * 3 + (i % 2 === 0 ? 0 : Math.PI);
                    x = Math.cos(angle) * 2; y = h; z = Math.sin(angle) * 2;
                } else if (currentType === 'vortex') {
                    const rad = (i / particleCount) * 6;
                    x = Math.cos(i * 0.2) * rad; y = (i / particleCount) * 8 - 4; z = Math.sin(i * 0.2) * rad;
                } else if (currentType === 'nebula') {
                    x = (Math.random() - 0.5) * 10; y = (Math.random() - 0.5) * 10; z = (Math.random() - 0.5) * 10;
                } else { // Saturn
                    const t = Math.random() * Math.PI * 2;
                    const u = Math.random() * 2 - 1;
                    const isRing = Math.random() > 0.35;
                    if (isRing) {
                        const r = 4 + Math.random() * 2.5;
                        x = Math.cos(t) * r; z = Math.sin(t) * r; y = (Math.random() - 0.5) * 0.3;
                    } else {
                        x = Math.cos(t) * Math.sqrt(1 - u * u) * 2.5;
                        y = Math.sin(t) * Math.sqrt(1 - u * u) * 2.5;
                        z = u * 2.5;
                    }
                }
                targetArray[i3] = x; targetArray[i3 + 1] = y; targetArray[i3 + 2] = z;
            }
        }

        // --- Interaction Logic ---
        let handLandmarker;
        const video = document.getElementById("webcam");
        const statusEl = document.getElementById("status-text");
        const noCamTag = document.getElementById("no-cam-tag");
        const aiHint = document.getElementById("ai-hint");

        async function initAI() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
                    runningMode: "VIDEO", numHands: 1
                });

                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.style.opacity = "0.7";
                useAI = true;
                aiHint.style.display = "block";
                statusEl.innerText = "Neural Link Active";
                video.addEventListener("loadeddata", predictAI);
            } catch (err) {
                console.warn("Camera not available, switching to mouse fallback.", err);
                statusEl.innerText = "Mouse Mode";
                noCamTag.style.display = "block";
                useAI = false;
            }
        }

        async function predictAI() {
            if (!useAI) return;
            const results = await handLandmarker.detectForVideo(video, performance.now());
            if (results.landmarks && results.landmarks[0]) {
                const hand = results.landmarks[0];

                mouseX = (0.5 - hand[9].x) * 18;
                mouseY = (0.5 - hand[9].y) * 12;

                const indexUp = hand[8].y < hand[6].y;
                const middleUp = hand[12].y < hand[10].y;
                const ringDown = hand[16].y > hand[14].y;

                const wasTwoFingers = isTwoFingers;
                isTwoFingers = indexUp && middleUp && ringDown;
                isFist = hand[8].y > hand[6].y && hand[12].y > hand[10].y;

                // Only call setTemplate when switching in/out of Text Mode
                if (isTwoFingers !== wasTwoFingers) {
                    setTemplate(isTwoFingers ? 'text' : document.getElementById('template').value);
                }

                if (!isTwoFingers && !isFist) {
                    const dx = hand[4].x - hand[20].x;
                    const dy = hand[4].y - hand[20].y;
                    const handSpan = Math.sqrt(dx * dx + dy * dy);
                    targetExpansion = Math.max(0.2, handSpan * 8.0);
                }
            }
            requestAnimationFrame(predictAI);
        }

        // --- Mouse & Keyboard Fallbacks ---
        window.addEventListener('mousemove', (e) => {
            if (useAI) return;
            mouseX = (e.clientX / window.innerWidth - 0.5) * 18;
            mouseY = (0.5 - e.clientY / window.innerHeight) * 12;
        });

        window.addEventListener('mousedown', () => { if (!useAI) isFist = true; });
        window.addEventListener('mouseup', () => { if (!useAI) isFist = false; });
        window.addEventListener('wheel', (e) => {
            if (useAI) return;
            targetExpansion = Math.min(Math.max(0.1, targetExpansion - e.deltaY * 0.001), 3.0);
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                isTwoFingers = !isTwoFingers;
                setTemplate(isTwoFingers ? 'text' : document.getElementById('template').value);
                e.preventDefault();
            }
        });

        // --- Main Loop ---
        function animate(time) {
            const baseColor = new THREE.Color(document.getElementById('pColor').value);
            currentExpansion = THREE.MathUtils.lerp(currentExpansion, targetExpansion, 0.08);

            // Pulse effect specifically for the Heart template
            const template = document.getElementById('template').value;
            let heartPulse = 1.0;
            if (template === 'heart' && !isTwoFingers && !isFist) {
                heartPulse = 1.0 + Math.sin(time * 0.005) * 0.1;
            }

            particleSystem.position.x = THREE.MathUtils.lerp(particleSystem.position.x, mouseX, 0.1);
            particleSystem.position.y = THREE.MathUtils.lerp(particleSystem.position.y, mouseY, 0.1);

            if (isTwoFingers) {
                statusEl.innerText = "MODE: I MISS YOU";
                statusEl.style.color = "#ff4d6d";
            } else if (isFist) {
                statusEl.innerText = "GRAVITY WELL";
                statusEl.style.color = "#ff4444";
            } else {
                statusEl.innerText = useAI ? "Neural Link Active" : "Mouse Mode";
                statusEl.style.color = "#00ffcc";
            }

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                let tx = targetArray[i3] * (isTwoFingers ? 1.0 : currentExpansion * heartPulse);
                let ty = targetArray[i3 + 1] * (isTwoFingers ? 1.0 : currentExpansion * heartPulse);
                let tz = targetArray[i3 + 2] * (isTwoFingers ? 1.0 : currentExpansion * heartPulse);

                if (isFist && !isTwoFingers) { tx = 0; ty = 0; tz = 0; }

                velocityArray[i3] = (velocityArray[i3] + (tx - posArray[i3]) * 0.05) * 0.8;
                velocityArray[i3 + 1] = (velocityArray[i3 + 1] + (ty - posArray[i3 + 1]) * 0.05) * 0.8;
                velocityArray[i3 + 2] = (velocityArray[i3 + 2] + (tz - posArray[i3 + 2]) * 0.05) * 0.8;

                posArray[i3] += velocityArray[i3];
                posArray[i3 + 1] += velocityArray[i3 + 1];
                posArray[i3 + 2] += velocityArray[i3 + 2];

                colors[i3] = baseColor.r; colors[i3 + 1] = baseColor.g; colors[i3 + 2] = baseColor.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.attributes.position.needsUpdate = true;

            particleSystem.rotation.y += 0.003;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // Initialize with HELLO intro
        setTemplate('hello');
        statusEl.innerText = "WELCOME";

        // After 3.5 seconds, morph to the selected template
        setTimeout(() => {
            if (!isTwoFingers) {
                setTemplate(document.getElementById('template').value);
                statusEl.innerText = useAI ? "Neural Link Active" : "Mouse Mode";
            }
        }, 3500);

        document.getElementById('template').addEventListener('change', (e) => setTemplate(e.target.value));
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initAI();
        animate();
    </script>
</body>

</html>